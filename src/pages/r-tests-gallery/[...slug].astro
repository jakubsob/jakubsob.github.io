---
import HeaderDefault from "../../components/HeaderDefault.astro";
import BaseLayout from "../../layouts/BaseLayout.astro";
import IDEInterface from "../../components/IDEInterface.jsx";

export async function getStaticPaths() {
  // GitHub API authentication for higher rate limits
  const GITHUB_TOKEN = import.meta.env.GITHUB_TOKEN;
  console.log("GitHub token available:", GITHUB_TOKEN ? "YES" : "NO");
  console.log("Token length:", GITHUB_TOKEN?.length || 0);
  const headers = GITHUB_TOKEN
    ? { Authorization: `token ${GITHUB_TOKEN}` }
    : {};
  console.log("Headers:", headers);

  // Helper function to build file tree with rate limit handling
  const buildFileTree = async (
    path: string,
    maxDepth: number = 3,
    currentDepth: number = 0
  ): Promise<any[]> => {
    if (currentDepth >= maxDepth) {
      return [];
    }

    try {
      const response = await fetch(
        `https://api.github.com/repos/jakubsob/r-tests-gallery/contents/${path}`,
        { headers }
      );

      if (!response.ok) {
        console.error(
          `API failed for ${path}: ${response.status} ${response.statusText}`
        );
        return [];
      }

      const contents = await response.json();

      if (!Array.isArray(contents)) {
        console.error(`Contents for ${path} is not an array, using fallback`);
        return [];
      }

      const tree: any[] = [];

      for (const item of contents) {
        if (item.type === "dir") {
          const children = await buildFileTree(
            item.path,
            maxDepth,
            currentDepth + 1
          );
          tree.push({
            ...item,
            children: children,
            isExpanded: true,
          });
        } else {
          tree.push(item);
        }
      }

      return tree;
    } catch (error) {
      console.error(`Error fetching contents for ${path}:`, error);
      return [];
    }
  };

  try {
    // Use GitHub Tree API for more efficient data fetching
    const treeResponse = await fetch(
      "https://api.github.com/repos/jakubsob/r-tests-gallery/git/trees/main?recursive=1",
      { headers }
    );

    let relevantDirs: any[] = [];

    if (treeResponse.ok) {
      const treeData = await treeResponse.json();

      // Extract top-level directories from the tree
      const directories = new Set<string>();

      treeData.tree.forEach((item: any) => {
        if (item.type === "tree" && item.path) {
          // Only get top-level directories (no nested paths)
          const topLevelDir = item.path.split("/")[0];
          if (!topLevelDir.startsWith(".") && topLevelDir !== "renv") {
            directories.add(topLevelDir);
          }
        }
      });

      // Convert to array with structure similar to contents API
      relevantDirs = Array.from(directories).map((dirName) => ({
        name: dirName,
        type: "dir",
        path: dirName,
      }));
    } else {
      console.error(
        "GitHub Tree API request failed:",
        treeResponse.status,
        treeResponse.statusText
      );
    }

    // If API failed or returned no dirs, return empty paths
    if (relevantDirs.length === 0) {
      console.error("No directories found or API failed");
      return [];
    }

    const paths: any[] = [];

    for (const dir of relevantDirs) {
      let fileTree: any[] = [];
      let hasError = false;

      // Try to build file tree from API
      if (treeResponse.ok) {
        fileTree = await buildFileTree(dir.name, 3);
      }

      // If API failed or returned empty tree, mark as error
      if (fileTree.length === 0) {
        hasError = true;
      }

      // Try to get README content
      let readmeContent = "";
      try {
        const readmeResponse = await fetch(
          `https://raw.githubusercontent.com/jakubsob/r-tests-gallery/main/${dir.name}/README.md`,
          { headers }
        );
        if (readmeResponse.ok) {
          readmeContent = await readmeResponse.text();
        }
      } catch (error) {
        console.log(`No README found for ${dir.name}`);
      }

      paths.push({
        params: { slug: dir.name },
        props: {
          dirName: dir.name,
          fileTree: fileTree,
          readmeContent: readmeContent,
          hasError: hasError,
        },
      });
    }

    return paths;
  } catch (error) {
    console.error("Error in getStaticPaths:", error);
    // Return empty paths instead of fallback
    return [];
  }
}

const { dirName, fileTree, readmeContent, hasError } = Astro.props as {
  dirName: string;
  fileTree: any[];
  readmeContent: string;
  hasError: boolean;
};
---

<!doctype html>
<html lang="en">
  <BaseLayout title={`${dirName} - R Tests Gallery`}>
    <main>
      <HeaderDefault class="fixed top-0 z-10" />
      <section
        id="hero"
        class="bg-sky-700 bg-noise h-[25vh]
        relative
        overflow-hidden
        text-white
        grid
        items-center justify-items-center
        grid-cols-1 grid-rows-1
        p-4"
      >
        <div class="text-center text-white">
          <h1
            class="text-white text-3xl py-2 font-syne tracking-wider capitalize"
          >
            {dirName.replace(/-/g, " ")}
          </h1>
        </div>
      </section>

      <!-- IDE-like Interface -->
      <IDEInterface
        fileTree={fileTree}
        readmeContent={readmeContent}
        dirName={dirName}
        hasError={hasError}
        client:load
      />
    </main>
  </BaseLayout>
</html>
