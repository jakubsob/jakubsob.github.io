---
import HeaderDefault from "../../components/HeaderDefault.astro";
import BaseLayout from "../../layouts/BaseLayout.astro";
import IDEInterface from "../../components/IDEInterface.jsx";

export async function getStaticPaths() {
  // GitHub API authentication for higher rate limits
  const GITHUB_TOKEN = import.meta.env.GITHUB_TOKEN;
  console.log("GitHub token available:", GITHUB_TOKEN ? "YES" : "NO");
  console.log("Token length:", GITHUB_TOKEN?.length || 0);
  const headers = GITHUB_TOKEN
    ? { Authorization: `token ${GITHUB_TOKEN}` }
    : {};
  console.log("Headers:", headers);

  // Helper function to build file tree with rate limit handling
  const buildFileTree = async (
    path: string,
    maxDepth: number = 3,
    currentDepth: number = 0
  ): Promise<any[]> => {
    if (currentDepth >= maxDepth) {
      return [];
    }

    try {
      const response = await fetch(
        `https://api.github.com/repos/jakubsob/r-tests-gallery/contents/${path}`,
        { headers }
      );

      if (!response.ok) {
        console.error(
          `API failed for ${path}: ${response.status} ${response.statusText}`
        );
        return [];
      }

      const contents = await response.json();

      if (!Array.isArray(contents)) {
        console.error(`Contents for ${path} is not an array, using fallback`);
        return [];
      }

      const tree: any[] = [];

      for (const item of contents) {
        if (item.type === "dir") {
          const children = await buildFileTree(
            item.path,
            maxDepth,
            currentDepth + 1
          );
          tree.push({
            ...item,
            children: children,
            isExpanded: true,
          });
        } else {
          tree.push(item);
        }
      }

      return tree;
    } catch (error) {
      console.error(`Error fetching contents for ${path}:`, error);
      return [];
    }
  };

  try {
    // Use GitHub Tree API for more efficient data fetching
    const treeResponse = await fetch(
      "https://api.github.com/repos/jakubsob/r-tests-gallery/git/trees/main?recursive=1",
      { headers }
    );

    let relevantDirs: any[] = [];

    if (treeResponse.ok) {
      const treeData = await treeResponse.json();

      // Extract top-level directories from the tree
      const directories = new Set<string>();

      treeData.tree.forEach((item: any) => {
        if (item.type === "tree" && item.path) {
          // Only get top-level directories (no nested paths)
          const topLevelDir = item.path.split("/")[0];
          if (!topLevelDir.startsWith(".") && topLevelDir !== "renv") {
            directories.add(topLevelDir);
          }
        }
      });

      // Convert to array with structure similar to contents API
      relevantDirs = Array.from(directories).map((dirName) => ({
        name: dirName,
        type: "dir",
        path: dirName,
      }));
    } else {
      console.error(
        "GitHub Tree API request failed:",
        treeResponse.status,
        treeResponse.statusText
      );
    }

    // If API failed or returned no dirs, return empty paths
    if (relevantDirs.length === 0) {
      console.error("No directories found or API failed");
      return [];
    }

    const paths: any[] = [];

    for (const dir of relevantDirs) {
      let fileTree: any[] = [];
      let hasError = false;

      // Try to build file tree from API
      if (treeResponse.ok) {
        fileTree = await buildFileTree(dir.name, 3);
      }

      // If API failed or returned empty tree, mark as error
      if (fileTree.length === 0) {
        hasError = true;
      }

      // Try to get README content
      let readmeContent = "";
      try {
        const readmeResponse = await fetch(
          `https://raw.githubusercontent.com/jakubsob/r-tests-gallery/main/${dir.name}/README.md`,
          { headers }
        );
        if (readmeResponse.ok) {
          readmeContent = await readmeResponse.text();
        }
      } catch (error) {
        console.log(`No README found for ${dir.name}`);
      }

      paths.push({
        params: { slug: dir.name },
        props: {
          dirName: dir.name,
          fileTree: fileTree,
          readmeContent: readmeContent,
          hasError: hasError,
        },
      });
    }

    return paths;
  } catch (error) {
    console.error("Error in getStaticPaths:", error);
    // Return empty paths instead of fallback
    return [];
  }
}

const { dirName, fileTree, readmeContent, hasError } = Astro.props as {
  dirName: string;
  fileTree: any[];
  readmeContent: string;
  hasError: boolean;
};
---

<!doctype html>
<html lang="en">
  <BaseLayout title={`${dirName} - R Tests Gallery`}>
    <main>
      <HeaderDefault class="fixed top-0 z-10" />
      <section
        id="hero"
        class="bg-sky-700 bg-noise h-[25vh]
        relative
        overflow-hidden
        text-white
        grid
        items-center justify-items-center
        grid-cols-1 grid-rows-1
        p-4"
      >
        <div class="text-center text-white">
          <div class="mb-2">
            <a
              href="/r-tests-gallery"
              class="inline-flex items-center text-sky-200 hover:text-white transition-colors text-sm"
            >
              <svg
                class="w-4 h-4 mr-1"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M15 19l-7-7 7-7"></path>
              </svg>
              Back to R Tests Gallery
            </a>
          </div>
          <h1
            class="text-white text-3xl py-2 font-syne tracking-wider capitalize"
          >
            {dirName.replace(/-/g, " ")}
          </h1>
          <div class="flex items-center justify-center gap-4 text-sm">
            <a
              href={`https://github.com/jakubsob/r-tests-gallery/tree/main/${dirName}`}
              target="_blank"
              rel="noopener noreferrer"
              class="inline-flex items-center text-sky-200 hover:text-white transition-colors"
            >
              <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 24 24">
                <path
                  d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"
                ></path>
              </svg>
              View on GitHub
            </a>
          </div>
        </div>
      </section>

      <!-- IDE-like Interface -->
      <IDEInterface
        fileTree={fileTree}
        readmeContent={readmeContent}
        dirName={dirName}
        hasError={hasError}
        client:load
      />
    </main>
  </BaseLayout>
</html>
